const
  GoInt = 'int',
  GoInt64 = 'int64',
  GoFloat64 = 'float64',
  GoSlice = 'slice',
  GoStruct = 'struct',
  GoString = 'string',
  GoBool = 'bool',
  GoTime = 'time.Time',
  GoInterface = 'interface{}';

function jsToGo(scope, typename, options) {
  let typeMap = {};
  let typeDeclare = '';
  let parentKey = '';

  let result = jsToGo0(scope, typename, options);
  result.go += typeDeclare;
  return result;

  function getTypeName() {
    let count = typeMap[parentKey];
    if (count !== undefined) {
      return format(parentKey + (typeMap[parentKey]++));
    }
    typeMap[parentKey] = 0;
    return format(parentKey);
  }

  function jsToGo0(scope, typename, options) {
    let go = '';
    let tabs = 0;
    let nested = options.nested;

    typename = format(typename || 'AutoGenerated');
    append(`type ${typename} `);

    parseScope(scope);

    return {go: go};

    function parseScope(scope, depth = 0) {
      let type = goType(scope);
      switch (type) {
        case GoSlice:
          parseSlice(scope, depth);
          break;
        case GoStruct:
          parseStruct(scope, undefined, depth + 1);
          break;
        default:
          append(type)
      }
    }

    function parseSlice(array, depth = 0) {
      let sliceLength = array.length;

      append('[]');

      switch (sliceLength) {
        case 0:
          parseScope(null, depth);
          return;
        case 1:
          parseScope(array[0], depth);
          return;
        default:
      }

      let sliceType = goSliceType(array);

      switch (sliceType) {
        case GoStruct:
          let StructFields = {};
          for (let ele of array) {
            let keys = Object.keys(ele);
            for (let keyName of keys) {
              if (!StructFields.hasOwnProperty(keyName)) {
                StructFields[keyName] = {
                  count: 0,
                  fieldTypeMap: {}
                }
              }
              let value = ele[keyName];
              StructFields[keyName].fieldTypeMap[goType(value)] = value;
              StructFields[keyName].count++;
            }
          }

          let structFieldNames = Object.keys(StructFields), struct = {}, omitempty = {};
          for (let fieldName of structFieldNames) {
            let elem = StructFields[fieldName];
            let fieldTypeMapNames = Object.keys(elem.fieldTypeMap);
            switch (fieldTypeMapNames.length) {
              case 1:
                let v = elem.fieldTypeMap[fieldTypeMapNames[0]];
                struct[fieldName] = v;
                break;
              default:
                struct[fieldName] = null
            }
            omitempty[fieldName] = elem.count !== sliceLength;
          }

          parseStruct(struct, omitempty, depth + 1);
          break;
        case GoSlice:
          let flatten = [];
          for (let slice of array) {
            flatten = flatten.concat(slice);
          }
          parseSlice(flatten, depth);
          return;
        default:
          append(sliceType || GoInterface);
      }
    }

    function parseStruct(object, omitempty, depth = 0) {
      if (depth > 1 && !nested) {
        let TypeName = getTypeName();
        append(TypeName);
        let nest = jsToGo0(object, TypeName, options);
        typeDeclare += `\n\n${nest.go}`;
        return
      }

      append('struct {\n');
      ++tabs;
      let keys = Object.keys(object);
      for (let i in keys) {
        if (keys.hasOwnProperty(i)) {
          let keyName = keys[i];
          indent(tabs);
          append(format(keyName) + ' ');
          parentKey = keyName;
          parseScope(object[keyName], depth);
          parentKey = '';

          parseTags(keyName, options, omitempty);
          append('\n');
        }
      }
      indent(--tabs);
      append('}');
    }

    function parseTags(keyName, options, omitempty) {
      if (!options || !options.tags || options.tags.length === 0) {
        return
      }
      append(' `');
      let tagResult = '';
      let tags = options.tags;
      for (let tag of tags) {
        tagResult += `${tag.key}:"${tag.isSnake ? camelToSnake(keyName) : keyName}`;
        if (omitempty && omitempty[keyName] === true) {
          tagResult += (',omitempty');
        }
        tagResult += '" '
      }
      append(tagResult.trim());
      append('`');
    }

    function indent(tabs) {
      for (let i = 0; i < tabs; i++)
        go += '\t';
    }

    function append(str) {
      go += str;
    }
  }
}

function goType(val) {
  if (val === null) {
    return GoInterface;
  } else if (Array.isArray(val)) {
    return GoSlice;
  }

  switch (typeof val) {
    case 'string':
      if (/\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(\.\d+)?(\+\d\d:\d\d|Z)/.test(val))
        return GoTime;
      else
        return GoString;
    case 'number':
      if (val % 1 === 0) {
        if (val > -2147483648 && val < 2147483647)
          return GoInt;
        else
          return GoInt64;
      } else
        return GoFloat64;
    case 'boolean':
      return GoBool;
    case 'object':
      return GoStruct;
    default:
      return GoInterface;
  }
}

function goSliceType(array) {
  let sliceType = null;
  for (let ele of array) {
    let thisType = goType(ele);
    if (sliceType === null)
      sliceType = thisType;
    else if (sliceType !== thisType) {
      sliceType = mostSpecificPossibleGoType(thisType, sliceType);
      if (sliceType === GoInterface)
        break;
    }
  }
  return sliceType
}

// Sanitizes and formats a string to make an appropriate identifier in Go
function format(str) {
  if (!str)
    return '';
  else if (str.match(/^\d+$/))
    str = 'Num' + str;
  else if (str.charAt(0).match(/\d/)) {
    let numbers = {
      '0': 'Zero_', '1': 'One_', '2': 'Two_', '3': 'Three_',
      '4': 'Four_', '5': 'Five_', '6': 'Six_', '7': 'Seven_',
      '8': 'Eight_', '9': 'Nine_'
    };
    str = numbers[str.charAt(0)] + str.substr(1);
  }
  return toProperCase(str).replace(/[^a-z0-9]/ig, '') || 'NAMING_FAILED';
}

// Given two types, returns the more specific of the two
function mostSpecificPossibleGoType(typ1, typ2) {
  if (typ1.substr(0, 5) === 'float'
    && typ2.substr(0, 3) === 'int')
    return typ1;
  else if (typ1.substr(0, 3) === 'int'
    && typ2.substr(0, 5) === 'float')
    return typ2;
  else
    return GoInterface;
}

// Proper cases a string according to Go conventions
function toProperCase(str) {
  // https://github.com/golang/lint/blob/5614ed5bae6fb75893070bdc0996a68765fdd275/lint.go#L771-L810
  const commonInitialisms = [
    "ACL", "API", "ASCII", "CPU", "CSS", "DNS", "EOF", "GUID", "HTML", "HTTP",
    "HTTPS", "ID", "IP", "JSON", "LHS", "QPS", "RAM", "RHS", "RPC", "SLA",
    "SMTP", "SQL", "SSH", "TCP", "TLS", "TTL", "UDP", "UI", "UID", "UUID",
    "URI", "URL", "UTF8", "VM", "XML", "XMPP", "XSRF", "XSS"
  ];

  return str.replace(/(^|[^a-zA-Z])([a-z]+)/g, function (unused, sep, frag) {
    if (commonInitialisms.indexOf(frag.toUpperCase()) >= 0)
      return sep + frag.toUpperCase();
    else
      return sep + frag[0].toUpperCase() + frag.substr(1).toLowerCase();
  }).replace(/([A-Z])([a-z]+)/g, function (unused, sep, frag) {
    if (commonInitialisms.indexOf(sep + frag.toUpperCase()) >= 0)
      return (sep + frag).toUpperCase();
    else
      return sep + frag;
  });
}

function camelToSnake(str) {
  if (typeof str !== 'string') {
    return '';
  }
  if (str.length < 2) {
    return str.toLowerCase();
  }
  str += 'L';
  let index = 0, strings = [];
  for (let i in str) {
    if (i === '0') {
      continue;
    }
    let decimal = str[i].charCodeAt(0);
    if (decimal >= 65 && decimal <= 90) {
      strings.push(str.substring(index, i).toLowerCase());
      index = i;
    }
  }
  return strings.join('_');
}

export default jsToGo;
